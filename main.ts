const pattern = /^((\s)+)?(\w+)(.)?:\s(\w+)(\<(.+)\>)?/

function onlyUnique(value: string, index: number, array: string[]) {
  return array.indexOf(value) === index;
}

interface TemplateType { 
  className: string,
  generics: string[],
  priors: { name: string, type: string }[],
  method: string,
  type: string,
  nextClass: string
  methodGenerics: string[]
}

const template = (p: TemplateType) => `
class ${p.className}${p.generics.length ? `<${p.generics.join(', ')}>` : ''} {${p.priors.length ? `
  constructor (
${p.priors.map((v) =>{
      return `      public ${v.name}: ${v.type}`
    }).join(',\n')}
  ) {}` : ''}
  ${p.method}${p.methodGenerics.length ? `<${p.methodGenerics.join(', ')}>` : ''}(${p.method}: ${p.type}) {
    return new ${p.nextClass}(
${[...p.priors.map(v => ({ name: `this.${v.name}`})), { name: p.method}].map(v =>{
        return `      ${v.name}`
      }).join(',\n')}
    )
  }
}
`.trim()

interface FinalTemplateType { 
  className: string,
  generics: string[],
  priors: { name: string, type: string }[],
}

const final = (p: FinalTemplateType) => `
class ${p.className}${p.generics.length ? `<${p.generics.join(', ')}>` : ''} {
  constructor (
${p.priors.map((v) =>{
      return `      public ${v.name}: ${v.type}`
    }).join(',\n')}
  ) {}
}
`.trim()

export function build (contents: string, g: { className: string, importsFrom?: string }) {
  const syntax = contents.split('\n').map(v => {
    const x = v.match(pattern)
    if (!x) return null

    const [
      _all,
      spaces,
      _ingore_one,
      variable,
      modifier,
      baseType,
      _arrowedGenerics,
      allGenerics,
    ] = x
    
    const optional = modifier ? modifier === "?" : false
    const nativeType = modifier ? modifier === "*" : false

    const indentations = (spaces || '').split('  ') 
    return {
      indentations: indentations.length - 1,
      nativeType,
      modifier,
      optional,
      spaces,
      variable,
      baseType,
      type: `${baseType}${allGenerics ? `<${allGenerics}>` : ''}`,
      generics: (allGenerics || '').replaceAll('\s', '').split(', ')
    }
  }).filter(s => s != null).map(s => s!)

  const nodes = syntax.map((here, i) => {
    const previous = syntax[i-1] || null
    const next = syntax[i+1] || null
    const sibling =
      ((previous && previous.indentations) === here.indentations) ||
      ((next && next.indentations) === here.indentations)
    const priors = syntax.slice(0, i).reverse()
    const priorsRev = priors.reverse()
    const parent = priorsRev.find(v => v.indentations === here.indentations - 1)
    return { ...here, priors, sibling, parent, previous, next, }
  })

  const nodeTemplates = nodes.map((node): TemplateType  => {
    const generics = node.priors.map(v => v.generics).flat().filter(onlyUnique).filter((str) => str !== '')
    return {
      className: `${g.className}_${node.variable}`,
      generics,
      priors: node.priors.map(v => ({ name: v.variable, type: v.type })),
      method: node.variable,
      type: node.type,
      methodGenerics: node.generics.filter(ng => !generics.includes(ng)).filter((str) => str !== ''),
      nextClass: (node.next && `${g.className}_${node.next.variable}`) || `${g.className}_final`
    }
  })

  const finalNodeTemplate = final({
    className: `${g.className}_final`,
    priors: nodes.map(v => ({ name: v.variable, type: v.type })),
    generics: nodes.map(v => v.generics).flat().filter(onlyUnique).filter((str) => str !== '')
  })

  const exportString = `export class ${g.className} extends ${nodeTemplates[0].className} {}`

  const i = g.importsFrom ? [`import {${nodes.filter(v => !v.nativeType).map(node => node.baseType).join(', ')}} from "${g.importsFrom}"`] : []

  const comment = [
    `// Generated by https://github.com/reggi/linear-builder-class`,
    `// Do not edit this code directly`
  ]

  return [...comment, ...i, ...nodeTemplates.map(template), finalNodeTemplate, exportString].join('\n')
}

